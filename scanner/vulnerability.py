import requests
from typing import List, Dict, Optional
from .utils.logger import setup_logger
import time
import re
from urllib.parse import quote

logger = setup_logger("vulnerability")

class CVEChecker:
    def __init__(self, api_key: Optional[str] = None):
        self.base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        self.api_key = api_key
        self.headers = {
            "User-Agent": "AdvancedNetworkScanner/1.0",
            "Accept": "application/json"
        }
        if self.api_key:
            self.headers["apiKey"] = self.api_key

    def _make_request(self, url: str, params: Dict = None) -> Optional[Dict]:
        """Helper method to make API requests with rate limiting and retries"""
        try:
            response = requests.get(url, headers=self.headers, params=params, timeout=30)
            
            # Handle 404 specifically - it means no vulnerabilities found, not an error
            if response.status_code == 404:
                logger.debug(f"No vulnerabilities found for search: {params}")
                return None
                
            response.raise_for_status()
            
            # Respect rate limits
            if not self.api_key:
                time.sleep(6)
                
            return response.json()
        except requests.exceptions.HTTPError as e:
            if e.response.status_code != 404:  # We already handled 404
                logger.error(f"HTTP error checking CVEs: {e}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"Request failed: {e}")
            return None

    def check_cve_by_cpe(self, cpe_name: str) -> List[Dict]:
        """Check for CVEs using CPE name (most accurate method)"""
        params = {'cpeName': cpe_name}
        data = self._make_request(self.base_url, params=params)
        if not data:
            return []
        return self._process_vulnerabilities(data)

    def check_cve_by_keyword(self, product: str, version: str) -> List[Dict]:
        """Check for CVEs using keyword search (fallback method)"""
        search_term = f"{product} {version}"
        params = {
            'keywordSearch': search_term,
            'keywordExactMatch': True
        }
        data = self._make_request(self.base_url, params=params)
        if not data:
            return []
        return self._process_vulnerabilities(data)

    def _process_vulnerabilities(self, data: Dict) -> List[Dict]:
        """Process vulnerabilities from API response into standardized format"""
        vulnerabilities = []
        
        for vuln in data.get('vulnerabilities', []):
            cve = vuln.get('cve', {})
            cve_id = cve.get('id', '')
            
            # Get description in English
            description = next(
                (desc['value'] for desc in cve.get('descriptions', [])
                if desc['lang'] == 'en'), 'No description available'
            )
            
            # Extract CVSS metrics (prioritize v3 over v2)
            metrics = cve.get('metrics', {})
            cvss_data = {}
            severity = 'UNKNOWN'
            base_score = 0.0
            
            for metric_type in ['cvssMetricV31', 'cvssMetricV30', 'cvssMetricV2']:
                if metric_type in metrics and metrics[metric_type]:
                    cvss_data = metrics[metric_type][0].get('cvssData', {})
                    severity = cvss_data.get('baseSeverity', 
                                           metrics[metric_type][0].get('baseSeverity', 'UNKNOWN'))
                    base_score = cvss_data.get('baseScore', 0.0)
                    break
            
            # Get references
            references = [ref['url'] for ref in cve.get('references', [])]
            
            vulnerabilities.append({
                'id': cve_id,
                'description': description,
                'severity': severity,
                'base_score': base_score,
                'vector': cvss_data.get('vectorString', ''),
                'references': references,
                'published': cve.get('published', ''),
                'last_modified': cve.get('lastModified', '')
            })
        
        return vulnerabilities


class VulnerabilityScanner:
    def __init__(self, api_key: Optional[str] = None):
        self.cve_checker = CVEChecker(api_key)
        self.cpe_cache = {}  # Cache for CPE strings
        
    def scan_device(self, device_info: Dict) -> List[Dict]:
        """Scan a device for vulnerabilities based on its services"""
        vulnerabilities = []
        
        for port, service in device_info.get('ports', {}).items():
            if not isinstance(service, dict):
                continue
                
            product = service.get('product', '').strip()
            version = service.get('version', '').strip()
            
            if not product or not version:
                continue
                
            # Clean version string (remove trailing +dfsg, -ubuntu, etc.)
            clean_version = self._clean_version(version)
            
            # Try to find CVEs
            cves = self._find_cves_for_service(product, clean_version)
            
            for cve in cves:
                vulnerabilities.append({
                    'port': int(port),
                    'service': f"{product} {clean_version}",
                    'cve_id': cve['id'],
                    'description': cve['description'],
                    'severity': cve['severity'],
                    'score': cve['base_score'],
                    'references': cve['references']
                })
        
        return vulnerabilities

    def _find_cves_for_service(self, product: str, version: str) -> List[Dict]:
        """Find CVEs using multiple methods with fallback"""
        logger.debug(f"Checking vulnerabilities for {product} {version}")
        
        # First try with CPE
        cpe = self._generate_cpe(product, version)
        if cpe:
            logger.debug(f"Trying CPE search: {cpe}")
            cves = self.cve_checker.check_cve_by_cpe(cpe)
            if cves:
                logger.debug(f"Found {len(cves)} vulnerabilities via CPE")
                return cves
            else:
                logger.debug("No vulnerabilities found via CPE search")
        
        # Fall back to keyword search
        logger.debug(f"Trying keyword search for '{product} {version}'")
        cves = self.cve_checker.check_cve_by_keyword(product, version)
        if cves:
            logger.debug(f"Found {len(cves)} vulnerabilities via keyword search")
        else:
            logger.debug("No vulnerabilities found via keyword search")
        
        return cves or []

    def _generate_cpe(self, product: str, version: str) -> Optional[str]:
        """Generate a CPE 2.3 string for common products"""
        # Check cache first
        cache_key = f"{product.lower()}_{version}"
        if cache_key in self.cpe_cache:
            return self.cpe_cache[cache_key]
        
        # Standardize product name
        product_lower = product.lower().replace(" ", "_")
        
        # Common product mappings
        cpe_mappings = {
            'mysql': f"cpe:2.3:a:mysql:mysql:{version}:*:*:*:*:*:*:*",
            'mariadb': f"cpe:2.3:a:mariadb:mariadb:{version}:*:*:*:*:*:*:*",
            'apache_http_server': f"cpe:2.3:a:apache:http_server:{version}:*:*:*:*:*:*:*",
            'httpd': f"cpe:2.3:a:apache:http_server:{version}:*:*:*:*:*:*:*",
            'nginx': f"cpe:2.3:a:nginx:nginx:{version}:*:*:*:*:*:*:*",
            'openssh': f"cpe:2.3:a:openbsd:openssh:{version}:*:*:*:*:*:*:*",
            'dropbear': f"cpe:2.3:a:dropbear_project:dropbear:{version}:*:*:*:*:*:*:*",
            'postgresql': f"cpe:2.3:a:postgresql:postgresql:{version}:*:*:*:*:*:*:*",
            'tomcat': f"cpe:2.3:a:apache:tomcat:{version}:*:*:*:*:*:*:*",
            'microsoft-iis': f"cpe:2.3:a:microsoft:iis:{version}:*:*:*:*:*:*:*"
        }
        
        # Try exact match first
        if product_lower in cpe_mappings:
            self.cpe_cache[cache_key] = cpe_mappings[product_lower]
            return cpe_mappings[product_lower]
        
        # Try partial matches
        for key, value in cpe_mappings.items():
            if key in product_lower:
                self.cpe_cache[cache_key] = value
                return value
                
        # Generic CPE format as last resort
        vendor = "unknown"
        if "_" in product_lower:
            vendor, product_name = product_lower.split("_", 1)
        else:
            product_name = product_lower
            
        cpe = f"cpe:2.3:a:{vendor}:{product_name}:{version}:*:*:*:*:*:*:*"
        self.cpe_cache[cache_key] = cpe
        return cpe

    def _clean_version(self, version: str) -> str:
        """Clean version strings by removing common suffixes"""
        # Remove common suffixes like +dfsg, -ubuntu0.1, etc.
        version = re.sub(r'[+-][a-z0-9.]+$', '', version)
        # Remove trailing non-version characters
        version = re.sub(r'[^0-9.]', '', version)
        return version or "unknown"